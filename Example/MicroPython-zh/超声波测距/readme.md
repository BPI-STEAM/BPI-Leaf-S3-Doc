# 超声波测距

声波 在1个标准大气压和15℃的条件下在空气中的传导速度约为340m/s。当一段声波从声源发出，到遇到障碍物而被反射传回声源所在的位置，声源与障碍物之间的距离，就是这段声波从发出到返回时所用总时间乘以声速除以2。

超声波具有指向性强，能量消耗缓慢，在介质中传播的距离较远的特点，在精度要求不是特别严苛且在非真空的条件下，很适合用于测量距离，设备成本也相对低廉。

压电式超声波发生器实际上是利用压电晶体的谐振来工作的，它有两个压电晶片和一个共振板。

![](https://i.imgur.com/pSNIm0h.png)

当它的两极外加脉冲信号，其频率等于压电陶瓷的固有振荡频率时，压电陶瓷将会发生共振，并带动共振板振动，便产生超声波。

反之，如果两电极间未外加电压，当共振板接收到超声波时，压电陶瓷将因力的作用而振动，将机械能转换为电信号，这时它就成为超声波接收器了。

在一个超声波测距模块上测得发射时与接收时的两段电信号之间的时间差，即为这个超声波测距模块此次发出的超声波的传播时间，进而可以计算出超声波发射源与障碍物之间的距离。

我们列一下计算公式，设发射与接收的时间差为**t**，单位为s，发射源与障碍物之间的距离为d，单位为m，声速为一个给定值340m/s，那么可列出以下公式。

**d = t * 340 / 2**

## HC-SR04超声波测距模块

![](https://i.imgur.com/ANULjOj.png)

该模块具有两个压电模块，左侧的作为超声波发生器，右侧的作为超声波接收器，具有配套电路元器件使其能正常工作。

模块引出四个管脚，VCC管脚接+5V直流电源，GND管脚则需要与其信号源共地，例如接收和发送信号的是一块开发板，则此GND要与开发板的GND相连。

Trig管脚用于接收发射超声波指令的电信号，当它接收到一次超过10us的高电平信号时，超声波发生器就会发出频率约为40kHz持续8周期的超声波。

Echo管脚默认输出低电平信号，当Trig触发时，它将转为高电平，在超声波接收器接收到返回的超声波时，它将转为低电平，其输出的高电平持续时间即为发射与接收的时间差。

![](https://i.imgur.com/j7H8WNn.png)

若在Trig触发后，超声波接收器并没有收到返回的超声波，Echo管脚输出的高电平也会在持续大约90ms后被拉低，这种设计是为了方便在循环检测时偶尔一次没接收到回波也能在此时间后拉低等待下一次的Trig触发，其信号接收端不会因为模块一次没有接收到回波而致使下一次检测的时间数据错误。

这个自动拉低的时间可能因不同的生产厂商调校及硬件性能不同而有所差异，这个时间数值应该是以该模块可检测最大距离（约15米）的声波往返时间为标准设置的。根据此时间数值，Trig触发间隔理应设置在100ms以上，以免出现两次Echo管脚输出的高电平信号合并，导致数据收集错误。

## 设计程序

在了解清楚了测距原理及具体使用的HC-SR04超声波测距模块的工作原理后，程序的设计思路应该就比较清晰了。

```python
from machine import Pin,time_pulse_us
import time
trig = Pin(1,Pin.OUT,pull=None)
echo = Pin(2,Pin.IN,pull=Pin.PULL_DOWN)
while True:
    trig.value(0)
    time.sleep_us(5)
    trig.value(1)
    time.sleep_us(10)
    trig.value(0)
    echo_pulse_time = time_pulse_us(echo,1,80_000)
    print("echo_pulse_time=%sus" % (echo_pulse_time))
    distance = echo_pulse_time / 1_000_000 *34_000 / 2
    print("distance=%scm" % (distance))
    time.sleep_ms(100)
```

首先我们需要使用`import`语句导入micropython标准库中的模块或函数，这通常是在最开始就要做的事情。当然也不需要一次性把所有的模块或函数统统都导入，把后续的代码中会调用到的模块或函数导入进来即可，例如现在我们仅需`machine`模块中的`Pin`，`time_pulse_us`，可以用`from machine import Pin,time_pulse_us`这样的方式。

在进行循环控制之前，我们可以先对`trig`，`echo`进行一次初始化操作，即分配对应要使用的GPIO管脚，初始化GPIO功能。不在循环语句里的代码只会在程序运行时按照从上到下的顺序执行一次，而初始化等仅需进行一次的操作，很适合将其写在循环语句的前面，在循环中反复执行反而有失效率。

在程序第4行对echo所在GPIO管脚做一个默认下拉电平的处理`pull=Pin.PULL_DOWN`，有利于减少信号干扰，在意外断开超声波模块连接时的效果最为明显，如果不做默认电平处理使GPIO管脚处于浮空状态，即使没有超声波模块的高电平信号发送过来，GPIO管脚也会因为接收到一些干扰信号而使程序做出错误的判断。trig也可以做相同的处理。

> 关于micropython标准库及其`machine`模块，可以参考micropython官方文档，例如此链接：[machine.Pin](https://docs.micropython.org/en/latest/library/machine.Pin.html)，即可查看其`Pin`的详细使用方法。

`machine.time_pulse_us(pin,value,timeout_us)`是我们引入的一个函数，它可以在我们给定的一个GPIO管脚`pin`上记录一个电平信号的持续时间；测量高电平时`value`的值为1，测量低电平则为0；可以设置一个超时时间`timeout_us`，单位为us，程序会先等待此超时时间直到电平信号触发，如果超过此时间则会返回-2并结束等待，如果信号已经触发则会立即开始计时；在电平信号触发后，程序会在此超时时间内记录触发时间，但若是电平信号持续时长超过了此超时时间则会返回-1并结束等待。

在While循环中，先拉低5us trig管脚再给10us高电平信号，可以保证其接收到一段独立的触发信号。

在获取echo高电平持续时间时，设置80000us的超时时间，这是以HC-SR04超声波模块echo最长信号持续时长为标准给定的，详见上文。

在循环最后输出echo高电平信号持续时间，计算距离，输出距离，休眠100ms。

`print`输出中应用了一种格式化文本的方法，`" "`内的字符通常会直接打印输出，但有一些关键字会被识别并执行其特定的功能，例如`%s`,它会将`" "`字符串后续一个`%`符号的右侧函数的数据填入此`%s`所在的位置，可以连续使用多个`%s`,程序会按照从左往右的顺序依次填入。

> 关于字符串，可以参考[python官方文档 字符串的方法](https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=str%20format#string-methods)，[菜鸟教程 python3字符串](https://www.runoob.com/python3/python3-string.html)，另外值得关注的字符串格式化方法还有`str.format()`，可以在这两个文档中找到。
> 对于python语法的学习，这几个文档能提供很大的帮助，[python官方文档 教程](https://docs.python.org/zh-cn/3/tutorial/index.html) ，[python官方文档 标准库](https://docs.python.org/zh-cn/3/library/index.html)对其中的模块与函数做了详尽及专业的说明，[菜鸟教程 python3](https://www.runoob.com/python3/python3-tutorial.html)中的说明则可能更通俗易懂，可以结合使用。

最后确保开发板与电脑的连接正常，HC-SR04超声波传感器模块四个管脚与开发板连接正常，VCC接+5V，GND接GND，Trig接GPIO1，Echo接GPIO2，这两个管脚也通过修改程序来改换其他GPIO。在Thonny IDE中运行程序即可在REPL中打印输出echo高电平信号持续时间，由此计算所得的距离。

## 程序报错与分析

如果REPL中打印输出语法报错，则查看具体提示的错误位置修正语法错误。

如果输出echo_pulse_time=-2，这意味着echo没有在超时时间以内发出高电平信号，通常这是trig根本没有触发导致的。如果没有正确连接HC-SR04超声波传感器模块，或模块损坏，echo则不可能收到信号。

如果输出echo_pulse_time=-1，这意味着echo没有在超时时间以内下拉电平，通常这是超声波接收器没有接收到回波导致的，超过检测距离，会导致这样的错误。另外有一些物理原因也会导致此错误，例如供电电压不足，有异物遮挡超声波发生器或接收器，或者其中一个损坏。